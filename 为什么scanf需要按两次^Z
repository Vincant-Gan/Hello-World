当scanf接受字符的时候，即
scanf("%d",&a)中a是一个char类型数，
或者
scanf("%c",&a)时，
会被scanf认为是在接受字符，这时候scanf的行为会变得与接受数字时有些不同
接受数字时，按下回车后，数字会立即被接受，但接受字符时，scanf的反应会慢一步，等到你输入第二个字符并按下回车后，它才会接受第一个字符
并且\n也会被留在缓冲区中，因此会出现这种情况
循环{scanf("%c",&a)}
输入如下序列：
1
2
3
^Z
^Z
输入结束
会得到什么呢，如果打开gdb观察的话，会发现\n也被输入了，字符输入的时候，\n也留在了缓冲区当中，并被读入
因此，如果你打算换行输入字符的话，就这样做
scanf("%c\n",&a)
另外，字符的输入，最好与数字的输入分开，否则数字也会染上这样的麻烦。

当然喽，如果是使用c++当中的cin的话就不会有这样的问题
如此看来，cin确实是一个智能输入的好帮手。
