这段代码是有问题的，我把象棋当围棋下了，使用了堵气的思路来判定黑将是否能活，没有考虑到围棋的子是可以动的，只要
黑将吃掉旁边的子，它依然可以有活路，那就要遍历黑将可以走到的点来判断了，这与我整个程序的思路大相径庭，所以我懒
得再写，就这样了，等哪天有心情了，再来看看。
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string.h>

using namespace std;

int board[9][10];

typedef struct{
    char name;
    int x;
    int y;
}piece;

void initboard(piece &a){
    memset(board, 0, sizeof(board));//全部设零
    //根据黑将的位置，确定他接下来有可能活的几个点
    if(a.x ==4 && a.y == 1){
        for(int y = 0; y < 3; ++y)
            for(int x = 3; x < 6; ++x){
                if(x == 4 && y == 1) continue;
                board[x][y] = 1;
            }
    }
    else{
        board[4][1] = 1;
        if(a.y == 1){
            board[a.x][0] = 1;
            board[a.x][2] = 1;
        }
        else{
            if(a.x == 4){
                board[3][a.y] = 1;
                board[5][a.y] = 1;
            }
            else{
                board[4][a.y] = 1;
                board[a.x][1] = 1;
            }
        }
    }
    board[a.x][a.y] = 1;
}

void killto(piece &a){
    for(int x = a.x - 1; x >= 0; --x){
        if(board[x][a.y] == 2) break;
        board[x][a.y] = 0;
    }
    for(int x = a.x + 1; x < 9; ++x){
        if(board[x][a.y] == 2) break;
        board[x][a.y] = 0;
    }
    for(int y = a.y - 1; y >= 0; --y){
        if(board[a.x][y] == 2) break;
        board[a.x][y] = 0;
    }
    for(int y = a.y + 1; y < 10; ++y){
        if(board[a.x][y] == 2) break;
        board[a.x][y] = 0;
    }
}

int main(){
    int n;
    piece black;
    piece red[7];
    cin >> n >> black.y >> black.x;
    --black.x;
    --black.y;
    black.name = 'G';
    initboard(black);
    int i = 0;
    while(i < n){
        cin >> red[i].name >> red[i].y >> red[i].x;
        --red[i].x;
        --red[i].y;
        board[red[i].x][red[i].y] = 2;
        ++i;
    }
    for(i = 0; i < n; ++i){
        piece it = red[i];
        if(it.name == 'G' || it.name == 'R') killto(it);
        if(it.name == 'H'){
            if(it.x - 2 >= 0 && board[it.x - 1][it.y] != 2){
                if(it.y - 1 >= 0) board[it.x - 2][it.y - 1] = 0;
                if(it.y + 1 < 10) board[it.x - 2][it.y + 1] = 0;
            }
            if(it.x + 2 < 9 && board[it.x + 1][it.y] != 2){
                if(it.y - 1 >= 0) board[it.x + 2][it.y - 1] = 0;
                if(it.y + 1 < 11) board[it.x + 2][it.y + 1] = 0;
            }
            if(it.y - 2 >= 0 && board[it.x][it.y - 1] != 2){
                if(it.x - 1 >= 0) board[it.x - 1][it.y - 2] = 0;
                if(it.x + 1 < 9) board[it.x + 1][it.y - 2] = 0;
            }
            if(it.y + 2 < 10 && board[it.x][it.y + 1] != 2){
                if(it.x - 1 >= 0) board[it.x - 1][it.y + 2] = 0;
                if(it.x + 1 < 9) board[it.x + 1][it.y + 2] = 0;
            }

        }
        if(it.name == 'C'){
            bool dam = false;
            for(int x = it.x - 1; x >=0; --x){
                if(board[x][it.y] == 2){
                    if(dam == false){
                        dam = true;
                        continue;
                    } 
                    else break;
                }
                if(dam == true) board[x][it.y] = 0;
            }
            dam = false;
            for(int x = it.x + 1; x < 9; ++x){
                if(board[x][it.y] == 2){
                    if(dam == false){
                        dam = true;
                        continue;
                    }
                    else break;
                }
                if(dam == true) board[x][it.y] = 0;
            }
            dam = false;
            for(int y = it.y - 1; y >=0; --y){
                if(board[it.x][y] == 2){
                    if(dam == false){
                        dam = true;
                        continue;
                    } 
                    else break;
                }
                if(dam == true) board[it.x][y] = 0;
            }
            dam = false;
            for(int y = it.y + 1; y < 10; ++y){
                if(board[it.x][y] == 2){
                    if(dam == false){
                        dam = true;
                        continue;
                    } 
                    else break;
                }
                if(dam == true) board[it.x][y] = 0;
            }
        }
    }
    bool live = false;
    for(int x = 3; x < 6; ++x){
        for(int y = 0; y < 3; ++y){
            if(board[x][y] == 1){
                live = true;
                break;
            }
        }
        if(live == true) break;
    }
    if(live == true){
        cout << "NO\n";
    }
    else{
        cout << "YES\n";
    }
    
    return 0;
}
